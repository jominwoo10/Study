■ 모니터
 조건 변수가 있는 모니터의 구조
- 모니터는 여러 측면에서 임계 영역과 비슷, 프로세스 실행 동안 상호배제와 동기화 제공
- 모니터 외부에 있는 프로세스가 모니터에 있는 프로세스 수행할 때 까지 외부에서 기다려야 할 때는 특정 조건에 따라 실행 재개 결정
- 모니터는 조건 변수와 프로세스를 대기할 수 있는 상황 연관 시킴
- 조건 변수에서 호출될 수 있는 연산은 wait와 signal 뿐이다 이 변수는 어떤 값을 저장 하려는 게 아니라 동기를 맞추려고 만들어짐
- x.wait() : 이 연산을 호출하는 프로세스는 다른 프로세스가 다음 연산을 호출될 때까지 중단 중단된 프로세스는 조건 변수 x에 대기
- signal() : 중단된 프로세스만 재개

■ 모니터와 세마포 비교
- 모니터의 조건 변수에서 x.wait와 x.signal 연산은 계수 세마포에서 P와 V연산과 비슷
  signal 연산이 다른 프로세스의 차단을 해제하는 동안 wait 연산이 프로세스의 실행을 차단할 수 있는데 이는 약간 차이가 있음. 세마포는 프로세스가 P연산을 실행하면 계수 세마포가 0보다 클 수 있어 해당 프로세스를 반드시 찯나하지 않음, 반면 wait 연산 실행하면 항상 프로세스 차단
- 세마포의 V연산 호출하면 일단 counter증가, 대기작업 유무 확인. 대기 작업이 있으면 큐에서 대기 작업 꺼내고, 해당 작업 실행, 반면 모니터는 signal연산(세마포의 V연산에 대응) 수행 시 대기 중인 작업 없으면 signal호출은 아무런 효과 발생하지 않음
- 세마포는 V연산, 모니터는 signal연산으로 모니터 잠금 해제 할 때만 .

■ 모니터의 개념과 구조
- 모니터 : 임계구역과 유사한 개념
- 동기화를 구현하기 위한 특수 프로그램 기법으로 특정 공유 자원을 프로세스에게 할당하는데 필요한 데이터와 이 데이터를 처리하는 프로시저로 구성됨
- 자료 추상화와 정보 은폐 개념을 기초로 하며 공유 자원을 할당하기 위한 병행성 구조
- 모니터 내의 공유 자원을 사용하려면 프로세스는 반드시 모니터의 진입부를 호출해야 함
- 외부의 프로세스는 직접 액세스할 수 없으며, 모니터의 경계에서 상호 배제가 시행됨
- 한 순간에 하나의 프로세스만 진입하여 자원을 사용할 수 있음
- 모니터에서 사용되는 연산은 wait와 signal이 있다

■ 교착 상태(deadlock)의 개념
- 다중 프로그래밍 시스템에서 프로세스가 결코 일어나지 않을 사건을 기다리는 상태
- 프로세스가 교착 상태에 빠지면 작업 정지되어 명령 진행 불가
- 운영체제가 교착 상태 해결 못하면, 시스템 운영자나 사용자는 작업 교체, 종료하는 외부 간섭으로 해결해야 함
- 하나 이상의 작업에 영향을 주어 무한 대기, 기아 상태보다 더 심각한 문제 야기

■ 프로세스의 자원 사용 순서
1) 자원 요청 : 프로세스가 필요한 자원 요청
	-> 해당 자원 다른 프로세스가 사용 중이면 요청을 수락 때까지 대기
2) 자원 사용

■ 컴퓨터 시스템에서 교착 상태의 발생 예
- 스풀링 시스템에서 발생하는 교착 상태
	-> 스풀링 시스템 교착 상태에 빠짐, 디스크에 할당된 스풀 공간의 출력 완료하지 않은 상태		   에서 다른 작업이 스풀 공간 모두 차지하면 교착 상태 발생
	-> 스풀링 처리부에 공간 넉넉하면 교착 상태 발생률 감소하니 비용 많이 듬
	   이때는 스풀링 파일의 일정 포화 임계치 설정하여 교착 상태 예방 가능
- 디스크를 공유할 때 발상하는 교착 상태
	-> 디스크 사용에 제어가 없으면 프로세스들이 서로 충돌하는 명령 요청시 교착 상태 발생

■ 교착 상태 발생의 네가지 조건 ★
1) 상호배제
-> 자원을 최소 하나 비공유 즉, 한 번에 프로세스 하나만 해당 자원 사용할 수 있어야 함
-> 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원 해제될 때 까지 대기

2) 점유와 대기
-> 자원을 최소 하나 정도 보유 다른 프로세스에 할당된 자원 얻으려고 대기하는 프로세스 있어야 함

3) 비선점
-> 자원 선점 불가 즉 자원은 강제로 빼앗을 수 없고 자원 점유하고 있는 프로세스가 끝나야 해제

4) 순환(환형)대기 (프로세스들이 체인을 구성하여 자원을 상호 요청)

ex) 강 건너기 예로 살펴본 교착 상태
- 상호배제 : 돌 하나를 한 사람만 디딜 수 있음
- 점유와 대기 : 각 사람은 돌 하나를 딛고 다음 돌을 요구
- 비선점 : 사람이 딛고 있는 돌을 강제로 제거할 수 없음
- 순환대기 : 왼쪽에서 오는 사람은 오른쪽에서 오는 사람 기다리고, 오른쪽에서 오는 사람도 왼쪽에서 오는 사람 기다림

■ 교착 상태의 표현
- 시스템 자원 할당 그래프인 방향 그래프 표현

■ 하벤더의 교착 상태 예방 방법->상호배제를 제외
- 각 프로세스는 필요한 자원을 한 번에 모두 요청해야 하며, 요청한 자원을 모두 제공받기 전 까지는 작업 진행이 불가
- 어떤 자원을 점유하고 있는 프로세스의 요청을 더 이상 허용하지 않으면 점유한 자원을 모두 반납하고, 필요할 때 다시 자원 요청 해야 한다
- 모든 프로레스에 자원을 순서대로 할당해야 한다

■ 보통 교착 상태 예방 방법
1) 자원의 상호배제 조건 방지
2) 점유와 대기 조건 방지
3) 비선점 조건 방지
4) 순환(환형) 대기 조건 방지

■ 교착 상태 해결 방법 세 가지★
1) 예방
2) 회피
3) 탐지 회복

■ 자원의 상호배제 조건 방지
- 상호배제는 자원의 비공유가 전제 되어야 함
- 일반적으로 상호배제 조건 만족하지 않으면 교착 상태 예방 불가능

■ 점유와 대기 조건 방지
- 점유와 대기 조건 발생 않으려면 프로세스가 작업 수행 전 필요한 자원 모두 요청하고 획득해야 함
- 대기상태에서는 프로세스가 자원 점유 불가능하므로 대기 조건 성립 안됨(최대 자원 할당)
- 점유와 대기 조건 방지 방법
	-> 자원 할당 시 시스템 호출된 프로세스 하나를 실행하는 데 필요한 모든 자원 먼저 할당, 	 	   실행 후 다른 시스템 호출에 자원 할당
- 점유와 대기 조건 방지 방법의 단점
	-> 자원 효율성 너무 낮음

■ 비선점 조건 방지
- 이미 할당된 자원에 선점권이 없어야 한다 전제 조건 필요
- 어떤 자원을 가진 프로세스가 다른 자원 요청한 자원을 즉시 할당 받을 수 없어 대기해야 한다면, 프로세스는 현재 가진 자원 모두 해제, 그리고 프로세스가 작업 시작할 때는 요청한 새로운 자원과 해제한 자원 확보해야함 이런 방법은 비선점 조건을 효과적으로 무효화시키지만 이미 실행한 작업의 상태를 잃을 수도 있음, 따라서 작업 상태를 쉽게 저장, 복구할 수 있을 때나 빈번하게 발생하지 않을 때만 좋은 방법
- 프로세스가 어떤 자원을 요청할 때 요청한 자원이 사용 가능한지 검사, 사용할 수 있다면 자원 할당, 사용할 수 없다면 대기 프로세스가 요청한 자원을 점유하고 있는지 검사, 요청한 자원을 대기 프로세스가 점유하고 있다면 자원을 해제하고 요청 프로세스에 할당

■ 순환(환형) 대기 조건 방지
- 모든 자원에 일련의 순서 부여, 각 프로세스가 오름차순으로만 자원을 요청할 수 있게 함
- 이는 계층척 요청 방법으로 순환 대기의 가능성 제거하여 교착 상태 예방
- 예상된 순서와 다르게 자원을 요청하는 작업은 실제로 자원을 사용하기 전부터 오랫동안 자원 할당받은 상태로 있어야하므로, 상당한 자원 낭비 초래

■ 교착 상태 예방시 고려할 규칙
- 각 프로세스는 오름차순으로만 자원 요청 가능
- 즉 프로세스는 임의의 자원 Ri 요청할 수 있지만 그 다음부터는 F(Rj) > F(Ri)일 때만 자원 요청
- 또 다른 해결 방법으로 프로세스가 자원 Rj 요청 때마다 F(Ri)>=F(Rj)가 되도록 Rj의 모든 자원 해제하는 것, 그러면 순환 대기 조건 막을 수 있음