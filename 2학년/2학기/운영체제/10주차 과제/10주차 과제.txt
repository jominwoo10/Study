■ 스케줄링의 개념
- 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 경정
- 자원이 프로세서인 경우를 프로세서 스케줄링, 대부분의 스케줄링이 프로세서 스케줄링 의미
- 스케줄링 방법에 따라 프로세스를 할당 받을 프로세스를 결정하므로 스케줄링이 시스템의 성능에 양향을 미침
- 좋은 스케줄링은 프로세서 효율성 높이고, 작업의 응답시간 최소화하여 시스템의 작업 처리 능력 향상
- 스케줄링이 필요 없는 프로세스(인터럽트 처리, 오류처리, 사용자의 시스템 호출 등)의 사전 처리가 대표적

■ 스케줄링의 목적
- 자원 할당의 공정성 보장
  -> 어느 프로세스도 무한정 실행이 연기되어서는 안됨
- 단위시간당 처리량 최대화
  -> 가능한 많은 프로세스에 서비스를 제공해야 한다
- 적절한 반환시간 보장
  -> 적절한 시간 안에 응답을 해야 한다
- 예측 가능성 보장
  -> 시스템 부화와 상관없이 거의 같은 시간 내에 비슷한 내용으로 실행 가능해야 함
- 오버헤드 최소화
- 자원 사용의 균형 유지
  -> 시스템의 자원을 쉬지 않고 사용할 수 있도록 스케줄링
- 반환시간과 자원의 활용 간에 균형 유지
  -> 응답 시간을 줄이기 위해서는 충분한 자원 확보, 허나 한 프로세스가 너무 많은 자원을 차지하     면 자원 활용도가 낮아진다
- 실행 대기 방지
  -> 실행을 무한 연기하지 않도록 해야한다
  -> 에이징 방법 : 오래 기다릴수록 높은 우선순위 부여
- 서비스 사용 기회 확대
  -> 프로세스에 더 자주 서비스 사용 기회를 주어야 한다
- 서비스 수 감소 방지
  -> 시스템 과부하시 갑작스런 서비스 수 감소 방지 필요
  -> 과부하를 방지하거나 프로세스들의 서비스를 줄여 과부하 대처

■ 프로세스의 실행
- 프로세서 버스트 : 프로세스를 프로세서에서 실행할 때
- 입출력 버스트 : 프로세스가 추가로 실행하려고 입출력을 기다리고 있을 때

■ 스케줄링 수행 단계
- 1단계 작업 스케줄링 : 작업 선택
  -> 실제로 시스템 자원을 사용할 작업 결정하는 작업 스케줄링, 승인 스케줄링이라고도 함
  -> 작업 스케줄링에 따라 작업 프로세스들로 나눠 생성, 수행 빈도가 적어 장기 스케줄링에 해당
- 2단계 작업 승인과 프로세서 결정 스케줄링 : 사용 권한 부여
  -> 프로세서 사용 권한 부여할 프로세스 결정하는 작업 승인과 프로세서 할당 스케줄링
  -> 시스템의 오버헤드에 따라 연기할 프로세스 잠정적으로 결정, 1단계 작업 스케줄링과 3단계 프       로세서 할당 스케줄링의 완충 역할, 수행 빈도를 기준으로 하면 중기 스케줄링에 해당, 메모리       사용성도 높이고 작업 효율성 향상시키는 스와핑(교체) 기능의 일부로 이해 가능
- 3단계 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
  -> 디스패치(분배기)가 준비 상태에 있는 프로세스 중에서 프로세서를 할당할 프로세스를 결정하는      프로세스 할당 스케줄링, 단기 스케줄링에 해당

■ 큐잉 도표
- 프로세스 스케줄링 표현하는 방법
  1) 프로세스가 입출력 요청 보내고 입출력 큐에 들어감
  2) 프로세스가 새로운 프로세스를 생성  fork하고 생성한 프로세스의 종료 대기
  3) 프로세스가 시간 할당량을 촤과(시간 종료)하면 준비 큐에 들어감
  4) 인터럽트로 프로세서에서 제거된 프로세스는 다시 준비 큐에 들어감
  1),2)의 경우 프로세스는 대기 상태에서 준비 상태로 전환, 다시 준비 큐에 들어감.
  프로세스는 종료할 때 까지 이 순환 반복

■ 스케줄러의 종류와 역할
- 장기 스케줄러
  -> 작업 스케줄러라고도 하며, 스케줄링에 따라 디스크에서 메모리로 작업을 가져와 처리할 순서        결정
  -> 스케줄링에 필요한 정보 : 제출 시간, 작업 이름, 작업 길이(용량) 등의 정보 필요
  -> 선택한 작업에 프로세스 제어 블록을 부착시켜 메모리를 적재한 것이 프로세스이다
- 단기 스케줄러
  -> 메모리에 적재된 프로세스 중 프로세서를 할당하여 실행 상태가 되도록 결정하는 프로세스 스케      줄링을 한다. 이때는 프로세스가 실행하는 데 필요한 자원의 요청을 만족해야 함

■ 장기 스케줄러와 단기 스케줄러 차이
- 장기 스케줄러와 단기 스케줄러의 가장 큰 차이는 실행 빈도
- 단기 스케줄러는 실행할 프로세스 수시로 선택, 매우 빨라야 함
- 장기 스케줄러는 시스템에 새로운 작업이 분 단위로 들어오므로 단기 스케줄러에 비해 상대적으로 드물게 수행, 장기 스케줄러는 다중 프로그래밍의 정도(메모리에 있는 프로세스 수)를 결정

■ 중기 스케줄러가 추가된 큐잉 도표
- 중기 스케줄러는 프로세스들이 프로세서를 서로 차지하려고 할 때 프로세스를 별도의 기억 장소에서 빼낼 수 있어 다중 프로그래밍의 정도 줄일 수 있음, 스왑 인과 스왑 아웃을 중기 스케줄러가 결정
- 스와핑 : 주기억장치에서 프로세스들을 임시로 제거(보조기억장치의 스왑 영역으로 이동) 다중 프로그래밍 정도를 완화 시키거나 작업의 혼합을 개선하거나 프로세스가 가지고 있던 메모리를 사용할 수 있게 하는데 필요

■ 선점 스케줄링
- 프로세스 하나가 장시간 동안 프로세서 독점 방지하여 모든 프로세스에 프로세서를 서비스할 기회 늘림, 따라서 우선순위가 높은 프로세스들이 긴급 처리 요청할 때 유용
  -> 실시간 시스템에서 인터럽트를 받아들이지 않으면 결과는 예측 불가
- 대화식 시분할 시스템이나 실시간 시스템에서 빠른 응답시간 유지하는데 선점 스케줄링은 필수
- 프로세서를 사용 가능할 때마다 실행할 수 있는 프로세스들이 준비 상태에 있어야 효과적
- 잦은 문맥교환의 발생으로 오버헤드가 크다
- 우선순위를 의미 있게 부여하지 않으면 효과 없음

■ 비선점 스케줄링
- 실행 시간이 짧은 프로세스(작업)가 실행 시간이 긴 프로세스(작업)를 기다리는 대신 모든 프로세서 공정 관리
- 우선순위간 높은 프로세스를 중간에 입력해도 대기 중인 프로세스는 영향을 받지 않으므로 응답시간 예측 용이하고 오버헤드가 작다
- 평균 응답시간의 증가, 우선순위 역전

■ 스케줄링 알고리즘 비교시 참조 기준
- 프로세서 사용률(CPU 이용률) : 가능한 CPU를 항상 실행 상태로 유지
- 처리율 : 단위시간 동안 완료된 프로세스들의 개수
- 반환시간 : 총처리 시간을 최소화
 	   -> CPU + I/O + wating + ready
- 대기시간 : 준비큐에서 기다리는 시간 최소화, 스케줄링 알고리즘에 따라 크게 차이남
- 반응시간 : 요청 후 첫 응답이 나오는데 까지 걸린 시간

■ 스케줄링의 개념
- 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 경정
- 자원이 프로세서인 경우를 프로세서 스케줄링, 대부분의 스케줄링이 프로세서 스케줄링 의미
- 스케줄링 방법에 따라 프로세스를 할당 받을 프로세스를 결정하므로 스케줄링이 시스템의 성능에 양향을 미침
- 좋은 스케줄링은 프로세서 효율성 높이고, 작업의 응답시간 최소화하여 시스템의 작업 처리 능력 향상
- 스케줄링이 필요 없는 프로세스(인터럽트 처리, 오류처리, 사용자의 시스템 호출 등)의 사전 처리가 대표적

■ 스케줄링의 목적
- 자원 할당의 공정성 보장
  -> 어느 프로세스도 무한정 실행이 연기되어서는 안됨
- 단위시간당 처리량 최대화
  -> 가능한 많은 프로세스에 서비스를 제공해야 한다
- 적절한 반환시간 보장
  -> 적절한 시간 안에 응답을 해야 한다
- 예측 가능성 보장
  -> 시스템 부화와 상관없이 거의 같은 시간 내에 비슷한 내용으로 실행 가능해야 함
- 오버헤드 최소화
- 자원 사용의 균형 유지
  -> 시스템의 자원을 쉬지 않고 사용할 수 있도록 스케줄링
- 반환시간과 자원의 활용 간에 균형 유지
  -> 응답 시간을 줄이기 위해서는 충분한 자원 확보, 허나 한 프로세스가 너무 많은 자원을 차지하     면 자원 활용도가 낮아진다
- 실행 대기 방지
  -> 실행을 무한 연기하지 않도록 해야한다
  -> 에이징 방법 : 오래 기다릴수록 높은 우선순위 부여
- 서비스 사용 기회 확대
  -> 프로세스에 더 자주 서비스 사용 기회를 주어야 한다
- 서비스 수 감소 방지
  -> 시스템 과부하시 갑작스런 서비스 수 감소 방지 필요
  -> 과부하를 방지하거나 프로세스들의 서비스를 줄여 과부하 대처

■ 프로세스의 실행
- 프로세서 버스트 : 프로세스를 프로세서에서 실행할 때
- 입출력 버스트 : 프로세스가 추가로 실행하려고 입출력을 기다리고 있을 때

■ 스케줄링 수행 단계
- 1단계 작업 스케줄링 : 작업 선택
  -> 실제로 시스템 자원을 사용할 작업 결정하는 작업 스케줄링, 승인 스케줄링이라고도 함
  -> 작업 스케줄링에 따라 작업 프로세스들로 나눠 생성, 수행 빈도가 적어 장기 스케줄링에 해당
- 2단계 작업 승인과 프로세서 결정 스케줄링 : 사용 권한 부여
  -> 프로세서 사용 권한 부여할 프로세스 결정하는 작업 승인과 프로세서 할당 스케줄링
  -> 시스템의 오버헤드에 따라 연기할 프로세스 잠정적으로 결정, 1단계 작업 스케줄링과 3단계 프       로세서 할당 스케줄링의 완충 역할, 수행 빈도를 기준으로 하면 중기 스케줄링에 해당, 메모리       사용성도 높이고 작업 효율성 향상시키는 스와핑(교체) 기능의 일부로 이해 가능
- 3단계 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
  -> 디스패치(분배기)가 준비 상태에 있는 프로세스 중에서 프로세서를 할당할 프로세스를 결정하는      프로세스 할당 스케줄링, 단기 스케줄링에 해당

■ 큐잉 도표
- 프로세스 스케줄링 표현하는 방법
  1) 프로세스가 입출력 요청 보내고 입출력 큐에 들어감
  2) 프로세스가 새로운 프로세스를 생성  fork하고 생성한 프로세스의 종료 대기
  3) 프로세스가 시간 할당량을 촤과(시간 종료)하면 준비 큐에 들어감
  4) 인터럽트로 프로세서에서 제거된 프로세스는 다시 준비 큐에 들어감
  1),2)의 경우 프로세스는 대기 상태에서 준비 상태로 전환, 다시 준비 큐에 들어감.
  프로세스는 종료할 때 까지 이 순환 반복

■ 스케줄러의 종류와 역할
- 장기 스케줄러
  -> 작업 스케줄러라고도 하며, 스케줄링에 따라 디스크에서 메모리로 작업을 가져와 처리할 순서        결정
  -> 스케줄링에 필요한 정보 : 제출 시간, 작업 이름, 작업 길이(용량) 등의 정보 필요
  -> 선택한 작업에 프로세스 제어 블록을 부착시켜 메모리를 적재한 것이 프로세스이다
- 단기 스케줄러
  -> 메모리에 적재된 프로세스 중 프로세서를 할당하여 실행 상태가 되도록 결정하는 프로세스 스케      줄링을 한다. 이때는 프로세스가 실행하는 데 필요한 자원의 요청을 만족해야 함

■ 장기 스케줄러와 단기 스케줄러 차이
- 장기 스케줄러와 단기 스케줄러의 가장 큰 차이는 실행 빈도
- 단기 스케줄러는 실행할 프로세스 수시로 선택, 매우 빨라야 함
- 장기 스케줄러는 시스템에 새로운 작업이 분 단위로 들어오므로 단기 스케줄러에 비해 상대적으로 드물게 수행, 장기 스케줄러는 다중 프로그래밍의 정도(메모리에 있는 프로세스 수)를 결정

■ 중기 스케줄러가 추가된 큐잉 도표
- 중기 스케줄러는 프로세스들이 프로세서를 서로 차지하려고 할 때 프로세스를 별도의 기억 장소에서 빼낼 수 있어 다중 프로그래밍의 정도 줄일 수 있음, 스왑 인과 스왑 아웃을 중기 스케줄러가 결정
- 스와핑 : 주기억장치에서 프로세스들을 임시로 제거(보조기억장치의 스왑 영역으로 이동) 다중 프로그래밍 정도를 완화 시키거나 작업의 혼합을 개선하거나 프로세스가 가지고 있던 메모리를 사용할 수 있게 하는데 필요

■ 선점 스케줄링
- 프로세스 하나가 장시간 동안 프로세서 독점 방지하여 모든 프로세스에 프로세서를 서비스할 기회 늘림, 따라서 우선순위가 높은 프로세스들이 긴급 처리 요청할 때 유용
  -> 실시간 시스템에서 인터럽트를 받아들이지 않으면 결과는 예측 불가
- 대화식 시분할 시스템이나 실시간 시스템에서 빠른 응답시간 유지하는데 선점 스케줄링은 필수
- 프로세서를 사용 가능할 때마다 실행할 수 있는 프로세스들이 준비 상태에 있어야 효과적
- 잦은 문맥교환의 발생으로 오버헤드가 크다
- 우선순위를 의미 있게 부여하지 않으면 효과 없음

■ 비선점 스케줄링
- 실행 시간이 짧은 프로세스(작업)가 실행 시간이 긴 프로세스(작업)를 기다리는 대신 모든 프로세서 공정 관리
- 우선순위간 높은 프로세스를 중간에 입력해도 대기 중인 프로세스는 영향을 받지 않으므로 응답시간 예측 용이하고 오버헤드가 작다
- 평균 응답시간의 증가, 우선순위 역전

■ 스케줄링 알고리즘 비교시 참조 기준
- 프로세서 사용률(CPU 이용률) : 가능한 CPU를 항상 실행 상태로 유지
- 처리율 : 단위시간 동안 완료된 프로세스들의 개수
- 반환시간 : 총처리 시간을 최소화
 	   -> CPU + I/O + wating + ready
- 대기시간 : 준비큐에서 기다리는 시간 최소화, 스케줄링 알고리즘에 따라 크게 차이남
- 반응시간 : 요청 후 첫 응답이 나오는데 까지 걸린 시간
■ 스케줄링의 개념
- 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 경정
- 자원이 프로세서인 경우를 프로세서 스케줄링, 대부분의 스케줄링이 프로세서 스케줄링 의미
- 스케줄링 방법에 따라 프로세스를 할당 받을 프로세스를 결정하므로 스케줄링이 시스템의 성능에 양향을 미침
- 좋은 스케줄링은 프로세서 효율성 높이고, 작업의 응답시간 최소화하여 시스템의 작업 처리 능력 향상
- 스케줄링이 필요 없는 프로세스(인터럽트 처리, 오류처리, 사용자의 시스템 호출 등)의 사전 처리가 대표적

■ 스케줄링의 목적
- 자원 할당의 공정성 보장
  -> 어느 프로세스도 무한정 실행이 연기되어서는 안됨
- 단위시간당 처리량 최대화
  -> 가능한 많은 프로세스에 서비스를 제공해야 한다
- 적절한 반환시간 보장
  -> 적절한 시간 안에 응답을 해야 한다
- 예측 가능성 보장
  -> 시스템 부화와 상관없이 거의 같은 시간 내에 비슷한 내용으로 실행 가능해야 함
- 오버헤드 최소화
- 자원 사용의 균형 유지
  -> 시스템의 자원을 쉬지 않고 사용할 수 있도록 스케줄링
- 반환시간과 자원의 활용 간에 균형 유지
  -> 응답 시간을 줄이기 위해서는 충분한 자원 확보, 허나 한 프로세스가 너무 많은 자원을 차지하     면 자원 활용도가 낮아진다
- 실행 대기 방지
  -> 실행을 무한 연기하지 않도록 해야한다
  -> 에이징 방법 : 오래 기다릴수록 높은 우선순위 부여
- 서비스 사용 기회 확대
  -> 프로세스에 더 자주 서비스 사용 기회를 주어야 한다
- 서비스 수 감소 방지
  -> 시스템 과부하시 갑작스런 서비스 수 감소 방지 필요
  -> 과부하를 방지하거나 프로세스들의 서비스를 줄여 과부하 대처

■ 프로세스의 실행
- 프로세서 버스트 : 프로세스를 프로세서에서 실행할 때
- 입출력 버스트 : 프로세스가 추가로 실행하려고 입출력을 기다리고 있을 때

■ 스케줄링 수행 단계
- 1단계 작업 스케줄링 : 작업 선택
  -> 실제로 시스템 자원을 사용할 작업 결정하는 작업 스케줄링, 승인 스케줄링이라고도 함
  -> 작업 스케줄링에 따라 작업 프로세스들로 나눠 생성, 수행 빈도가 적어 장기 스케줄링에 해당
- 2단계 작업 승인과 프로세서 결정 스케줄링 : 사용 권한 부여
  -> 프로세서 사용 권한 부여할 프로세스 결정하는 작업 승인과 프로세서 할당 스케줄링
  -> 시스템의 오버헤드에 따라 연기할 프로세스 잠정적으로 결정, 1단계 작업 스케줄링과 3단계 프       로세서 할당 스케줄링의 완충 역할, 수행 빈도를 기준으로 하면 중기 스케줄링에 해당, 메모리       사용성도 높이고 작업 효율성 향상시키는 스와핑(교체) 기능의 일부로 이해 가능
- 3단계 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
  -> 디스패치(분배기)가 준비 상태에 있는 프로세스 중에서 프로세서를 할당할 프로세스를 결정하는      프로세스 할당 스케줄링, 단기 스케줄링에 해당

■ 큐잉 도표
- 프로세스 스케줄링 표현하는 방법
  1) 프로세스가 입출력 요청 보내고 입출력 큐에 들어감
  2) 프로세스가 새로운 프로세스를 생성  fork하고 생성한 프로세스의 종료 대기
  3) 프로세스가 시간 할당량을 촤과(시간 종료)하면 준비 큐에 들어감
  4) 인터럽트로 프로세서에서 제거된 프로세스는 다시 준비 큐에 들어감
  1),2)의 경우 프로세스는 대기 상태에서 준비 상태로 전환, 다시 준비 큐에 들어감.
  프로세스는 종료할 때 까지 이 순환 반복

■ 스케줄러의 종류와 역할
- 장기 스케줄러
  -> 작업 스케줄러라고도 하며, 스케줄링에 따라 디스크에서 메모리로 작업을 가져와 처리할 순서        결정
  -> 스케줄링에 필요한 정보 : 제출 시간, 작업 이름, 작업 길이(용량) 등의 정보 필요
  -> 선택한 작업에 프로세스 제어 블록을 부착시켜 메모리를 적재한 것이 프로세스이다
- 단기 스케줄러
  -> 메모리에 적재된 프로세스 중 프로세서를 할당하여 실행 상태가 되도록 결정하는 프로세스 스케      줄링을 한다. 이때는 프로세스가 실행하는 데 필요한 자원의 요청을 만족해야 함

■ 장기 스케줄러와 단기 스케줄러 차이
- 장기 스케줄러와 단기 스케줄러의 가장 큰 차이는 실행 빈도
- 단기 스케줄러는 실행할 프로세스 수시로 선택, 매우 빨라야 함
- 장기 스케줄러는 시스템에 새로운 작업이 분 단위로 들어오므로 단기 스케줄러에 비해 상대적으로 드물게 수행, 장기 스케줄러는 다중 프로그래밍의 정도(메모리에 있는 프로세스 수)를 결정

■ 중기 스케줄러가 추가된 큐잉 도표
- 중기 스케줄러는 프로세스들이 프로세서를 서로 차지하려고 할 때 프로세스를 별도의 기억 장소에서 빼낼 수 있어 다중 프로그래밍의 정도 줄일 수 있음, 스왑 인과 스왑 아웃을 중기 스케줄러가 결정
- 스와핑 : 주기억장치에서 프로세스들을 임시로 제거(보조기억장치의 스왑 영역으로 이동) 다중 프로그래밍 정도를 완화 시키거나 작업의 혼합을 개선하거나 프로세스가 가지고 있던 메모리를 사용할 수 있게 하는데 필요

■ 선점 스케줄링
- 프로세스 하나가 장시간 동안 프로세서 독점 방지하여 모든 프로세스에 프로세서를 서비스할 기회 늘림, 따라서 우선순위가 높은 프로세스들이 긴급 처리 요청할 때 유용
  -> 실시간 시스템에서 인터럽트를 받아들이지 않으면 결과는 예측 불가
- 대화식 시분할 시스템이나 실시간 시스템에서 빠른 응답시간 유지하는데 선점 스케줄링은 필수
- 프로세서를 사용 가능할 때마다 실행할 수 있는 프로세스들이 준비 상태에 있어야 효과적
- 잦은 문맥교환의 발생으로 오버헤드가 크다
- 우선순위를 의미 있게 부여하지 않으면 효과 없음

■ 비선점 스케줄링
- 실행 시간이 짧은 프로세스(작업)가 실행 시간이 긴 프로세스(작업)를 기다리는 대신 모든 프로세서 공정 관리
- 우선순위간 높은 프로세스를 중간에 입력해도 대기 중인 프로세스는 영향을 받지 않으므로 응답시간 예측 용이하고 오버헤드가 작다
- 평균 응답시간의 증가, 우선순위 역전

■ 스케줄링 알고리즘 비교시 참조 기준
- 프로세서 사용률(CPU 이용률) : 가능한 CPU를 항상 실행 상태로 유지
- 처리율 : 단위시간 동안 완료된 프로세스들의 개수
- 반환시간 : 총처리 시간을 최소화
 	   -> CPU + I/O + wating + ready
- 대기시간 : 준비큐에서 기다리는 시간 최소화, 스케줄링 알고리즘에 따라 크게 차이남
- 반응시간 : 요청 후 첫 응답이 나오는데 까지 걸린 시간
■ 스케줄링의 개념
- 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 경정
- 자원이 프로세서인 경우를 프로세서 스케줄링, 대부분의 스케줄링이 프로세서 스케줄링 의미
- 스케줄링 방법에 따라 프로세스를 할당 받을 프로세스를 결정하므로 스케줄링이 시스템의 성능에 양향을 미침
- 좋은 스케줄링은 프로세서 효율성 높이고, 작업의 응답시간 최소화하여 시스템의 작업 처리 능력 향상
- 스케줄링이 필요 없는 프로세스(인터럽트 처리, 오류처리, 사용자의 시스템 호출 등)의 사전 처리가 대표적

■ 스케줄링의 목적
- 자원 할당의 공정성 보장
  -> 어느 프로세스도 무한정 실행이 연기되어서는 안됨
- 단위시간당 처리량 최대화
  -> 가능한 많은 프로세스에 서비스를 제공해야 한다
- 적절한 반환시간 보장
  -> 적절한 시간 안에 응답을 해야 한다
- 예측 가능성 보장
  -> 시스템 부화와 상관없이 거의 같은 시간 내에 비슷한 내용으로 실행 가능해야 함
- 오버헤드 최소화
- 자원 사용의 균형 유지
  -> 시스템의 자원을 쉬지 않고 사용할 수 있도록 스케줄링
- 반환시간과 자원의 활용 간에 균형 유지
  -> 응답 시간을 줄이기 위해서는 충분한 자원 확보, 허나 한 프로세스가 너무 많은 자원을 차지하     면 자원 활용도가 낮아진다
- 실행 대기 방지
  -> 실행을 무한 연기하지 않도록 해야한다
  -> 에이징 방법 : 오래 기다릴수록 높은 우선순위 부여
- 서비스 사용 기회 확대
  -> 프로세스에 더 자주 서비스 사용 기회를 주어야 한다
- 서비스 수 감소 방지
  -> 시스템 과부하시 갑작스런 서비스 수 감소 방지 필요
  -> 과부하를 방지하거나 프로세스들의 서비스를 줄여 과부하 대처

■ 프로세스의 실행
- 프로세서 버스트 : 프로세스를 프로세서에서 실행할 때
- 입출력 버스트 : 프로세스가 추가로 실행하려고 입출력을 기다리고 있을 때

■ 스케줄링 수행 단계
- 1단계 작업 스케줄링 : 작업 선택
  -> 실제로 시스템 자원을 사용할 작업 결정하는 작업 스케줄링, 승인 스케줄링이라고도 함
  -> 작업 스케줄링에 따라 작업 프로세스들로 나눠 생성, 수행 빈도가 적어 장기 스케줄링에 해당
- 2단계 작업 승인과 프로세서 결정 스케줄링 : 사용 권한 부여
  -> 프로세서 사용 권한 부여할 프로세스 결정하는 작업 승인과 프로세서 할당 스케줄링
  -> 시스템의 오버헤드에 따라 연기할 프로세스 잠정적으로 결정, 1단계 작업 스케줄링과 3단계 프       로세서 할당 스케줄링의 완충 역할, 수행 빈도를 기준으로 하면 중기 스케줄링에 해당, 메모리       사용성도 높이고 작업 효율성 향상시키는 스와핑(교체) 기능의 일부로 이해 가능
- 3단계 프로세서 할당 스케줄링 : 준비 상태의 프로세스에 프로세서 할당(디스패칭)
  -> 디스패치(분배기)가 준비 상태에 있는 프로세스 중에서 프로세서를 할당할 프로세스를 결정하는      프로세스 할당 스케줄링, 단기 스케줄링에 해당

■ 큐잉 도표
- 프로세스 스케줄링 표현하는 방법
  1) 프로세스가 입출력 요청 보내고 입출력 큐에 들어감
  2) 프로세스가 새로운 프로세스를 생성  fork하고 생성한 프로세스의 종료 대기
  3) 프로세스가 시간 할당량을 촤과(시간 종료)하면 준비 큐에 들어감
  4) 인터럽트로 프로세서에서 제거된 프로세스는 다시 준비 큐에 들어감
  1),2)의 경우 프로세스는 대기 상태에서 준비 상태로 전환, 다시 준비 큐에 들어감.
  프로세스는 종료할 때 까지 이 순환 반복

■ 스케줄러의 종류와 역할
- 장기 스케줄러
  -> 작업 스케줄러라고도 하며, 스케줄링에 따라 디스크에서 메모리로 작업을 가져와 처리할 순서        결정
  -> 스케줄링에 필요한 정보 : 제출 시간, 작업 이름, 작업 길이(용량) 등의 정보 필요
  -> 선택한 작업에 프로세스 제어 블록을 부착시켜 메모리를 적재한 것이 프로세스이다
- 단기 스케줄러
  -> 메모리에 적재된 프로세스 중 프로세서를 할당하여 실행 상태가 되도록 결정하는 프로세스 스케      줄링을 한다. 이때는 프로세스가 실행하는 데 필요한 자원의 요청을 만족해야 함

■ 장기 스케줄러와 단기 스케줄러 차이
- 장기 스케줄러와 단기 스케줄러의 가장 큰 차이는 실행 빈도
- 단기 스케줄러는 실행할 프로세스 수시로 선택, 매우 빨라야 함
- 장기 스케줄러는 시스템에 새로운 작업이 분 단위로 들어오므로 단기 스케줄러에 비해 상대적으로 드물게 수행, 장기 스케줄러는 다중 프로그래밍의 정도(메모리에 있는 프로세스 수)를 결정

■ 중기 스케줄러가 추가된 큐잉 도표
- 중기 스케줄러는 프로세스들이 프로세서를 서로 차지하려고 할 때 프로세스를 별도의 기억 장소에서 빼낼 수 있어 다중 프로그래밍의 정도 줄일 수 있음, 스왑 인과 스왑 아웃을 중기 스케줄러가 결정
- 스와핑 : 주기억장치에서 프로세스들을 임시로 제거(보조기억장치의 스왑 영역으로 이동) 다중 프로그래밍 정도를 완화 시키거나 작업의 혼합을 개선하거나 프로세스가 가지고 있던 메모리를 사용할 수 있게 하는데 필요

■ 선점 스케줄링
- 프로세스 하나가 장시간 동안 프로세서 독점 방지하여 모든 프로세스에 프로세서를 서비스할 기회 늘림, 따라서 우선순위가 높은 프로세스들이 긴급 처리 요청할 때 유용
  -> 실시간 시스템에서 인터럽트를 받아들이지 않으면 결과는 예측 불가
- 대화식 시분할 시스템이나 실시간 시스템에서 빠른 응답시간 유지하는데 선점 스케줄링은 필수
- 프로세서를 사용 가능할 때마다 실행할 수 있는 프로세스들이 준비 상태에 있어야 효과적
- 잦은 문맥교환의 발생으로 오버헤드가 크다
- 우선순위를 의미 있게 부여하지 않으면 효과 없음

■ 비선점 스케줄링
- 실행 시간이 짧은 프로세스(작업)가 실행 시간이 긴 프로세스(작업)를 기다리는 대신 모든 프로세서 공정 관리
- 우선순위간 높은 프로세스를 중간에 입력해도 대기 중인 프로세스는 영향을 받지 않으므로 응답시간 예측 용이하고 오버헤드가 작다
- 평균 응답시간의 증가, 우선순위 역전

■ 스케줄링 알고리즘 비교시 참조 기준
- 프로세서 사용률(CPU 이용률) : 가능한 CPU를 항상 실행 상태로 유지
- 처리율 : 단위시간 동안 완료된 프로세스들의 개수
- 반환시간 : 총처리 시간을 최소화
 	   -> CPU + I/O + wating + ready
- 대기시간 : 준비큐에서 기다리는 시간 최소화, 스케줄링 알고리즘에 따라 크게 차이남
- 반응시간 : 요청 후 첫 응답이 나오는데 까지 걸린 시간

■ 스케줄링 알고리즘
1) 선입선처리 스케줄링
2) 최소작업 우선 스케줄링
3) 우선 순위 스케줄링
4) 라운드 로빈 스케줄링
5) 다단계 큐 스케줄링
6) 다단계 피드백 큐 스케줄링
7) hrn 스케줄링
8) 다중 프로세서 스케줄링
9) 스레드 스케줄링

■ 선입선처리 스케줄링의 개념 (비선점)
- 비선점 방법으로 프로세서 스케줄링 알고리즘 중 가장 단손
- 프로세서 요청하는 순서대로 프로세서 할당, 선입선출 큐로 구현
- 일괄처리 시스템에서는 매우 효율적이나 빠른 응답을 요청하는 대화식 시스템에는 적합하지 않음

■ 선입선처리 스케줄링 - 동적 상황에서의 성능
1) 프로세서 중심 프로세스가 CPU를 할당받아 실행되는 동안 입출력 중심 프로세스는 입출력 마치고
준비 큐로 이동하여 CPU를 기다림, 즉 입출력장치들은 쉼(입출력장치는 비어 있음)
2) 프로세서 중심 프로세스가 CPU의 사용 마치고 입출력장치로 이동, 프로세서 버스트가 짧은 입출력 중심 프로세스가 CPU를 신속하게 사용 후 다시 입출력장치 사용하려고 입출력장치 큐로 이동, 이때 프로세서는 쉼(CPU가 비어있음)
3) 프로세서 중심 프로세스가 다시 준비 큐로 이동하여 CPU를 할당받고, 모든 입출력 중심 프로세스는 프로세서 중심 프로세스의 처리가 끝날 때까지 준비 큐에서 대기(반복 처리)

■ 선입선처리 스케줄링 - 장점과 단점 (비선점)
장점) - 스케줄링의 이해와 구현이 단순하다
      - 준비 큐에 있는 모든 프로세스가 결국 실행되므로 기아 없는 공정한 정책이다
      - 프로세서가 지속적으로 유용한 프로세스를 수행해야 처리율이 높다
단점) - 비선점식이므로 대화식 프로세스에는 부적합하다
      - 장기 실행 프로세스가 뒤의 프로세스를 모두 지연시켜 평균 대기산이 길어져 최악의 대기시        간이 된다
      - 긴 프로세스가 실행되는 동안 짧은 프로세스가 긴 대기시간이므로 호위 효과가 발생할 수 있        다

■ 최소작업 우선 스케줄링의 개념
- 각 작업의 프로세서 실행 시간 이용하여 프로세서가 사용 가능할 때 실행시간이 가장 짧은 작업에 할당하는 방법

■ 최소작업 우선 스케줄링 - 장점과 단점
장점) - 항상 실행 시간이 짧은 작업을 신속하게 실행하므로 평균 대기시간이 가장 짧다
단점) - 초기의 긴 작업을 짧은 작업을 종료할 때까지 대기시켜 기아가 발생한다
      - 기본적으로 짧은 작업이 항상 실행되도록 설정하므로 불공정한 작업을 실행한다
      - 실행 시간을 예측하기가 어려워 실용적이지 못하다